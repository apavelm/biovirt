@page "/renderer"
@using System.Numerics
@using BioVirt.Client.ViewModel
@using Blazor.Extensions
@using Blazor.Extensions.Canvas.WebGL

<PageTitle>WebGL canvas</PageTitle>

<div tabindex="0">
    <BECanvas Width="800" Height="600" @ref="_canvasReference" />
</div>

@code {
    private BECanvasComponent _canvasReference;
    private WebGLContext _gl;

    private ProgramInfo _programInfo;

    private Buffers _buffers;


    private readonly float[] _positions = new float[] {
        // Front face
        -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f,

        // Back face
        -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f,

        // Top face
        -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f,

        // Bottom face
        -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f,

        // Right face
        1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f,

        // Left face
        -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
    };

    private readonly ushort[] _indices = new ushort[] {
        0,
        1,
        2,
        0,
        2,
        3, // front
        4,
        5,
        6,
        4,
        6,
        7, // back
        8,
        9,
        10,
        8,
        10,
        11, // top
        12,
        13,
        14,
        12,
        14,
        15, // bottom
        16,
        17,
        18,
        16,
        18,
        19, // right
        20,
        21,
        22,
        20,
        22,
        23, // left
    };

    private readonly float[] _colors = new float[]
    {
            1.0f, 1.0f, 1.0f, 1.0f, // Front face (white)
            1.0f, 1.0f, 1.0f, 1.0f,
            1.0f, 1.0f, 1.0f, 1.0f,
            1.0f, 1.0f, 1.0f, 1.0f,

            1.0f, 0.0f, 0.0f, 1.0f, // Back face (red)
            1.0f, 0.0f, 0.0f, 1.0f,
            1.0f, 0.0f, 0.0f, 1.0f,
            1.0f, 0.0f, 0.0f, 1.0f,

            0.0f, 1.0f, 0.0f, 1.0f, // Top face (green)
            0.0f, 1.0f, 0.0f, 1.0f,
            0.0f, 1.0f, 0.0f, 1.0f,
            0.0f, 1.0f, 0.0f, 1.0f,

            0.0f, 0.0f, 1.0f, 1.0f, // Bottom face (blue)
            0.0f, 0.0f, 1.0f, 1.0f,
            0.0f, 0.0f, 1.0f, 1.0f,
            0.0f, 0.0f, 1.0f, 1.0f,

            1.0f, 1.0f, 0.0f, 1.0f, // Right face (yellow)
            1.0f, 1.0f, 0.0f, 1.0f,
            1.0f, 1.0f, 0.0f, 1.0f,
            1.0f, 1.0f, 0.0f, 1.0f,

            1.0f, 0.0f, 1.0f, 1.0f, // Left face (purple)
            1.0f, 0.0f, 1.0f, 1.0f,
            1.0f, 0.0f, 1.0f, 1.0f,
            1.0f, 0.0f, 1.0f, 1.0f,
    };

    private float _cameraX = 0, _cameraY = 0, _cameraZoom = 1, _cameraRotation = 0;
    private float[] _viewProjectionMatrix;

    private bool _isDragging = false;
    private float startMouseX, startMouseY;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _gl = await _canvasReference.CreateWebGLAsync();
            _programInfo = new ProgramInfo();
            _buffers = new Buffers();

            await _gl.ClearColorAsync(0.8f, 0.8f, 0.8f, 1.0f);


            await InitializeShadersAsync();
            await InitializeBuffersAsync();

            await DrawSceneAsync(0.5f);
        }
    }

    private async Task InitializeShadersAsync()
    {
        var vertexShader = await CreateShaderAsync(ShaderType.VERTEX_SHADER, @"attribute vec4 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    varying lowp vec4 vColor;

    void main(void) {
      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      vColor = aVertexColor;
    }");

        var fragmentShader = await CreateShaderAsync(ShaderType.FRAGMENT_SHADER, @"varying lowp vec4 vColor;

    void main(void) {
      gl_FragColor = vColor;
    }");

        _programInfo.Program = await CreateProgramAsync(vertexShader, fragmentShader);

        _programInfo.AttribLocations.VertexPosition = await _gl.GetAttribLocationAsync(_programInfo.Program, "aVertexPosition");
        _programInfo.AttribLocations.VertexColor = await _gl.GetAttribLocationAsync(_programInfo.Program, "aVertexColor");

        _programInfo.UniformLocations.ModelViewMatrix = await _gl.GetUniformLocationAsync(_programInfo.Program, "uModelViewMatrix");
        _programInfo.UniformLocations.ProjectionMatrix = await _gl.GetUniformLocationAsync(_programInfo.Program, "uProjectionMatrix");
    }

    private async Task InitializeBuffersAsync()
    {
        _buffers.Position = await _gl.CreateBufferAsync();
        await _gl.BindBufferAsync(BufferType.ARRAY_BUFFER, _buffers.Position);
        await _gl.BufferDataAsync(BufferType.ARRAY_BUFFER, _positions, BufferUsageHint.STATIC_DRAW);

        _buffers.Indices = await _gl.CreateBufferAsync();
        await _gl.BindBufferAsync(BufferType.ELEMENT_ARRAY_BUFFER, _buffers.Indices);
        await _gl.BufferDataAsync(BufferType.ELEMENT_ARRAY_BUFFER, _indices, BufferUsageHint.STATIC_DRAW);

        _buffers.Color = await _gl.CreateBufferAsync();
        await _gl.BindBufferAsync(BufferType.ARRAY_BUFFER, _buffers.Color);
        await _gl.BufferDataAsync(BufferType.ARRAY_BUFFER, _colors, BufferUsageHint.STATIC_DRAW);
    }


    // private async Task DrawSceneAsync()
    // {
    //     await _gl.ClearAsync(BufferBits.COLOR_BUFFER_BIT);

    //     _viewProjectionMatrix = MultiplyMatrices(
    //         CreateProjectionMatrix(_canvasReference.Width, _canvasReference.Height),
    //         CreateCameraMatrix(_cameraX, _cameraY, _cameraRotation, _cameraZoom)
    //     );

    //     await _gl.UseProgramAsync(_program);

    //     await _gl.BindBufferAsync(BufferType.ARRAY_BUFFER, _positionBuffer);
    //     await _gl.VertexAttribPointerAsync(0, 2, DataType.FLOAT, false, 0, 0);
    //     await _gl.EnableVertexAttribArrayAsync(0);

    //     await _gl.BindBufferAsync(BufferType.ELEMENT_ARRAY_BUFFER, _indexBuffer);

    //     float[] color = { 1.0f, 0.0f, 0.0f, 1.0f };
    //     await _gl.UniformAsync(_uColorLocation, color);

    //     float[] modelMatrix = CreateCameraMatrix(100, 100, 0, 1);
    //     float[] matrix = MultiplyMatrices(_viewProjectionMatrix, modelMatrix);
    //     await _gl.UniformMatrixAsync(_uMatrixLocation, false, matrix);

    //     await _gl.DrawElementsAsync(Primitive.TRIANGLES, _indices.Length, DataType.UNSIGNED_SHORT, 0);
    // }

    public async Task DrawSceneAsync(float cubeRotation)
    {
        await _gl.ClearColorAsync(0f, 0f, 0f, 1f); // Clear to black
        await _gl.ClearDepthAsync(1f);            // Clear everything
        await _gl.EnableAsync(EnableCap.DEPTH_TEST);
        await _gl.DepthFuncAsync(CompareFunction.LEQUAL);
        await _gl.ClearAsync(BufferBits.COLOR_BUFFER_BIT | BufferBits.DEPTH_BUFFER_BIT);

        // Perspective matrix
        float fieldOfView = (float)(45 * Math.PI / 180);
        float aspect = _gl.DrawingBufferWidth / (float)_gl.DrawingBufferHeight;
        float zNear = 0.1f;
        float zFar = 100.0f;
        Matrix4x4 projectionMatrix = Matrix4x4.CreatePerspectiveFieldOfView(fieldOfView, aspect, zNear, zFar);

        // ModelView matrix
        Matrix4x4 modelViewMatrix = Matrix4x4.Identity;
        modelViewMatrix = Matrix4x4.CreateTranslation(0f, 0f, -6f) * modelViewMatrix;
        modelViewMatrix = Matrix4x4.CreateFromAxisAngle(Vector3.UnitZ, cubeRotation) * modelViewMatrix;
        modelViewMatrix = Matrix4x4.CreateFromAxisAngle(Vector3.UnitY, cubeRotation * 0.7f) * modelViewMatrix;
        modelViewMatrix = Matrix4x4.CreateFromAxisAngle(Vector3.UnitX, cubeRotation * 0.3f) * modelViewMatrix;

        // Set position and color attributes
        await SetPositionAttributeAsync();
        await SetColorAttributeAsync();

        // Bind indices buffer
        await _gl.BindBufferAsync(BufferType.ELEMENT_ARRAY_BUFFER, _buffers.Indices);

        // Use program
        await _gl.UseProgramAsync(_programInfo.Program);

        // Set uniforms
        float[] fProjMatrix = new float[]
        {
            projectionMatrix.M11, projectionMatrix.M12, projectionMatrix.M13, projectionMatrix.M14,
            projectionMatrix.M21, projectionMatrix.M22, projectionMatrix.M23, projectionMatrix.M24,
            projectionMatrix.M31, projectionMatrix.M32, projectionMatrix.M33, projectionMatrix.M34,
            projectionMatrix.M41, projectionMatrix.M42, projectionMatrix.M43, projectionMatrix.M44
        };

        float[] fmodelViewMatrix = new float[]
        {
            modelViewMatrix.M11, modelViewMatrix.M12, modelViewMatrix.M13, modelViewMatrix.M14,
            modelViewMatrix.M21, modelViewMatrix.M22, modelViewMatrix.M23, modelViewMatrix.M24,
            modelViewMatrix.M31, modelViewMatrix.M32, modelViewMatrix.M33, modelViewMatrix.M34,
            modelViewMatrix.M41, modelViewMatrix.M42, modelViewMatrix.M43, modelViewMatrix.M44
        };

        await _gl.UniformMatrixAsync(_programInfo.UniformLocations.ProjectionMatrix, false, fProjMatrix);
        await _gl.UniformMatrixAsync(_programInfo.UniformLocations.ModelViewMatrix, false, fmodelViewMatrix);

        // Draw elements
        await _gl.DrawElementsAsync(Primitive.TRIANGLES, 36, DataType.UNSIGNED_SHORT, 0);
    }

    private async Task SetPositionAttributeAsync()
    {
        int numComponents = 3;
        bool normalize = false;
        int stride = 0;
        int offset = 0;

        await _gl.BindBufferAsync(BufferType.ARRAY_BUFFER, _buffers.Position);
        await _gl.VertexAttribPointerAsync((uint)_programInfo.AttribLocations.VertexPosition, numComponents, DataType.FLOAT, normalize, stride, offset);
        await _gl.EnableVertexAttribArrayAsync((uint)_programInfo.AttribLocations.VertexPosition);
    }

    private async Task SetColorAttributeAsync()
    {
        int numComponents = 4;
        bool normalize = false;
        int stride = 0;
        int offset = 0;

        await _gl.BindBufferAsync(BufferType.ARRAY_BUFFER, _buffers.Color);
        await _gl.VertexAttribPointerAsync((uint)_programInfo.AttribLocations.VertexColor, numComponents, DataType.FLOAT, normalize, stride, offset);
        await _gl.EnableVertexAttribArrayAsync((uint)_programInfo.AttribLocations.VertexColor);
    }         

    private async Task<WebGLShader> CreateShaderAsync(ShaderType type, string source)
    {
        var shader = await _gl.CreateShaderAsync(type);
        await _gl.ShaderSourceAsync(shader, source);
        await _gl.CompileShaderAsync(shader);

        var success = await _gl.GetShaderParameterAsync<bool>(shader, ShaderParameter.COMPILE_STATUS);
        if (!success)
        {
            var info = await _gl.GetShaderInfoLogAsync(shader);
            throw new Exception($"Shader compilation failed: {info}");
        }

        return shader;
    }

    private async Task<WebGLProgram> CreateProgramAsync(WebGLShader vertexShader, WebGLShader fragmentShader)
    {
        var program = await _gl.CreateProgramAsync();
        await _gl.AttachShaderAsync(program, vertexShader);
        await _gl.AttachShaderAsync(program, fragmentShader);
        await _gl.LinkProgramAsync(program);

        var success = await _gl.GetProgramParameterAsync<bool>(program, ProgramParameter.LINK_STATUS);
        if (!success)
        {
            var info = await _gl.GetProgramInfoLogAsync(program);
            throw new Exception($"Program linking failed: {info}");
        }

        return program;
    }

    private static float[] CreateProjectionMatrix(float width, float height)
    {
        return new float[] {
            2.0f / width, 0, 0,
            0, -2.0f / height, 0,
            -1, 1, 1
    };
    }

    private static float[] CreateCameraMatrix(float x, float y, float rotation, float zoom)
    {
        float cos = (float)Math.Cos(rotation);
        float sin = (float)Math.Sin(rotation);
        float scale = 1.0f / zoom;

        return new float[] {
            cos * scale, -sin * scale, 0,
            sin * scale, cos * scale, 0,
            -x, -y, 1
    };
    }

    private static float[] MultiplyMatrices(float[] a, float[] b)
    {
        return new float[] {
            a[0] * b[0] + a[3] * b[1] + a[6] * b[2],
            a[1] * b[0] + a[4] * b[1] + a[7] * b[2],
            a[2] * b[0] + a[5] * b[1] + a[8] * b[2],
            a[0] * b[3] + a[3] * b[4] + a[6] * b[5],
            a[1] * b[3] + a[4] * b[4] + a[7] * b[5],
            a[2] * b[3] + a[5] * b[4] + a[8] * b[5],
            a[0] * b[6] + a[3] * b[7] + a[6] * b[8],
            a[1] * b[6] + a[4] * b[7] + a[7] * b[8],
            a[2] * b[6] + a[5] * b[7] + a[8] * b[8]
    };
    }
    
}
